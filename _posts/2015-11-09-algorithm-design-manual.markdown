---
layout: post
title:  "draft:アルゴリズム設計マニュアル"
date:   2015-11-09 22:00:00
categories: 
---

# draft:アルゴリズム設計マニュアル

アルゴリズムとデータ構造のとてもよい教科書。
読み返すついでにメモを残してみる。

## 第1章 アルゴリズム設計への導入
- 良いアルゴリズムの3つの望ましい性質: 正しく、効率的で、容易に実装できること
- アルゴリズムが常に正しい答えを出力するのに対し、ヒューリスティックは正しい動作をする保証がない。
  - 例: 巡回セールスマン問題: 全探索(n!)アルゴリズムは正しいが極めて遅く、最近接点や最近接ペアヒューリステックは明らかな弱点がある
  - 例: 映画撮影スケジューリング問題: 最初に終わる仕事を選択するというよいアルゴリズムが存在。撮影区間に切れ目がある場合にはよいアルゴリズムはない。
- アルゴリズムには正しさの論証が必要
- アルゴリズムの表現: アイディアを表現した自然言語、疑似コード、プログラムコード。明確にアイディアを表現することが大切。
- 問題の記述: (1) 許される入力例の集合、 (2) アルゴリズムの出力に要求される性質
- 反例はアルゴリズムの誤りを示す強力な方法。不必要な詳細を拭い去った単純な反例がよい。
  - 反例の探し方: 小さく考える、網羅的に考える、弱点を探す、同点(タイ)を作る、極端なものを探す
- アルゴリズムの証明には数学的帰納法がよく使われる
- アルゴリズムを実問題に応用するためには応用問題を抽象的なデータ構造に変換することが大切
  - データ構造: 順列、部分集合、木、グラフ、点や点集合、多角形、文字列
- 再帰的な思考が大切。上記のデータ構造はいずれも一部を取ると同じ種類のデータ構造が得られる再帰的なデータ構造であることに留意せよ。

## 第2章 アルゴリズム解析
- 計算量: 最悪計算量、最良計算量、平均計算量
  - 本にはないが償却計算量というのものある。平均計算量は独立施行、償却計算量は同一系列での連続施行。平均の意味合いは不明確で、最悪を考えるのが有益。
- ビッグオー記法: f(n)=O(g(n))とは、c*g(n)がf(n)の上界であることを示す。Ω(・)は下界、Θ(・)はO(・)かつΩ(・)であることを表す。
  - おもな計算時間のクラス: O(1), O(log(n)), O(n), O(n*log(n)), O(n^2), O(2^n), O(n!)
- 計算量の事例: 挿入ソート、選択ソート、行列の積
- 対数の概念は重要。
  - **二分探索はアルゴリズム設計における最も強力なアイディアの一つ**。
  - 平衡二分木(またはn分木)の高さは葉の数やノードの数のlog。
  - n通りのビットパターンを表せる最小のビット数はlog(n)。
  - a^nの高速な再帰的計算

## 第3章 データ構造
- データ構造の選択は臓器移植なみに効く。
- データ構造の大別
  - 連続 (contiguous) 構造: 配列、行列、ヒープ、ハッシュテーブル
  - 連結 (linked) 構造: リスト、木、グラフの隣接リスト表現
- 配列
  - 長所: 定数時間アクセス、領域の効率、メモリの局所性
  - 短所: サイズ固定。動的配列(領域が足りなくなったら倍々に拡張)で解決できる。動的配列へのアクセスは最悪時定数時間ではなくなるが、償却(amorized)定数時間。
- 連結リスト
  - 長所: オーバーフローが起こらない、挿入と削除は配列より簡単、レコードサイズが大きいときポインタ操作のほうが効率的
  - 短所: ポインタ格納に余分な領域が必要、ランダムアクセスに弱い、キャッシュが効きにくい
- コンテナ: データアイテムを、その内容と無関係に保管したり取り出したりできるデータ構造。
  - スタック: push, popメソッドを備える。LIFO。
  - キュー: enqueue, dequeuqメソッドを備える。FIFO、最悪待ち時間の最小化。
  - 辞書(dictionary): KVS。search, insert, deleteメソッドを備える。さらに、 max, min, predecessor(ソート順での一つ前の要素), successor(ソート順での一つ次の要素)を備える場合もある。
- いろいろなデータ構造を使って辞書を実装したとき  

------------ | ----------- | ----------- | ------------- | ------------- | ------------- | ------------- | -------------- |
             |             |             | リンクリスト  | リンクリスト  | リンクリスト  | リンクリスト  |                |
     メソッド| 未ソート配列| 配列        | 単方向        | 双方向        | 単方向        | 単方向        | 平衡二分探索木 |
             |             | ソート済み  | 未ソート      | 未ソート      | ソート済み    | ソート済み    |                |
------------ | ----------- | ----------- | ------------- | ------------- | ------------- | ------------- | -------------- |
search       | O(n)        | O(logn)     | O(n)          | O(n)          | O(n)          | O(n)          |        O(logn) |
insert       | O(1)        | O(n)        | O(1)          | O(1)          | O(n)          | O(n)          |        O(logn) |
delete       | O(1)(*)     | O(n)        | O(n) (**)     | O(1)          | O(n) (**)     | O(1)          |        O(logn) |
successor    | O(n)        | O(1)        | O(n)          | O(n)          | O(1)          | O(1)          |        O(logn) |
predecessor  | O(n)        | O(1)        | O(n)          | O(n)          | O(n) (**)     | O(1)          |        O(logn) |
max          | O(n)        | O(1)        | O(n)          | O(n)          | O(1)          | O(1)          |        O(logn) |
min          | O(n)        | O(1)        | O(n)          | O(n)          | O(1) (***)    | O(1)          |        O(logn) |
------------ | ----------- | ----------- | ------------- | ------------- | ------------- | ------------- | -------------- |

(\*)サーチはすでにできているとする

(\*\*)サーチができていても前ノードを探すのに先頭から探索しなおす必要がある

(\*\*\*)リストの末尾ポインタを保持しておくものとする

- 二分探索木
  - 配列とリンクリストを見る限り、探索と更新にはトレードオフ。
  - 二分探索木を使えば探索、挿入、削除の3操作はいずれもO(h)。
  - n!通りの挿入順序が等確率だとすると、平均ではhはO(logn)だが、最悪ではO(n)。
  - 平衡二分探索木の実装は赤黒木(この本では2色木と書いてある)やスプレイ木などがあり、すべての辞書操作がO(logn)でできる。
  - 平衡二分探索木をブラックボックスとして使ってO(nlogn)のソートが自然な形で実現できる。

- 優先順位付きキュー: insert, find-minimum, delete-minimum の3メソッドを備える抽象データ構造
- いろいろなデータ構造を使って優先順位付きキューを実装したとき  

-------------- | ----------- | ----------- | -------------
     メソッド  | 未ソート配列| 配列        | 平衡二分探索木
               |             | ソート済み  | 
-------------- | ----------- | ----------- | -------------
insert         |        O(1) |        O(n) |       O(logn)
find-minimum   |     O(1)(*) |        O(1) |       O(1)(*)
delete-minimum |        O(n) |        O(1) |       O(logn)
-------------- | ----------- | ----------- | -------------

(*) insert時に最小要素へのポインタを保持しておく

- ハッシュ表
  - キーを整数に写像する。衝突がなければ辞書のsearch, insert, deleteがいずれもO(1)になる。実用的には辞書を実装するベストの方法。
  - 衝突回避: 連鎖法 (各バケットをリンクリストにする)、開アドレス法 (挿入時に衝突が見つかったら次のアドレスに要素を入れる)。
  - 連鎖法はメモリを食う。開アドレス法は充填率が上がってきたときの要素削除で大量の要素再配置が発生する。
- 双方向リンクリストを使った連鎖法による要素数mのハッシュ表を使って辞書を実現したとき

------------ |------------ |------------
             |             |
     メソッド|　ハッシュ表 | ハッシュ表
             |  平均       | 最悪
------------ |------------ |------------
search       |      O(n/m) |        O(n)
insert       |        O(1) |        O(1)
delete       |        O(1) |        O(1)
successor    |      O(n+m) |      O(n+m)
predecessor  |      O(n+m) |      O(n+m)
max          |      O(n+m) |      O(n+m)
min          |      O(n+m) |      O(n+m)
------------ |------------ |------------

- ハッシングを用いた効率的な文字列探索: Rolling hash を使った Rabin-Karp のアルゴリズム。素朴な実装の最悪計算時間はO(mn)、Rabin-Karpのアルゴリズムの期待時間はO(m+n)



# (復習用)問題集

以下の問題について、(1)自然言語と図、(2)疑似コード、(3)コード、(4)最悪計算量と平均計算量、を答えよ。

- p.3 挿入ソート
- (p.12 映画撮影スケジューリング問題の最適スケジューリング)
- p.47 選択ソート
- p.49 愚直な文字列パターンマッチング
- (p.75 動的配列)
- p.76 単方向連結リストの実装と探索、挿入、削除
- (双方向連結リストの実装と探索、挿入、削除)
- (p.80 スタックの実装、pushとpop演算)
- (p.80 キューの実装、enqueueとdequeue演算)
- {未ソート、ソート済み}{配列、単方向リンクリスト、双方向リンクリスト}を用いて辞書を実装したときの、search, insert, delete, predecessor, successor, max, min メソッドの時間計算量 (コードは書かなくていい)
- p.87 二分木の実装 : 親へのポインタあり
- p.87 二分探索木の探索、p.88 最小要素探索、 pre-order, in-order, post-orderでのtraverse, p.89 挿入、削除の時間計算量 (コードは複雑なので書かなくていい)、predecessor、successor
- p.92 平衡探索木を使い、(1) insertとin-order traverseのみ、 (2)min, successor, insert のみ、 (3) min, insert, delete, search のみ、でそれぞれ O(nlogn)時間でソートする方法(コードは書かなくていい)
- p.94 未ソート配列、ソート済み配列、平衡二分探索木を使って優先順位付きキューを実装したときの、insert, find-minimum, delete-minimum メソッドの時間計算量 (コードは書かなくていい)
- p.101 Rabin-Karp の文字列検索アルゴリズム